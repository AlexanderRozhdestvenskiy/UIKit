import UIKit

// MARK: Cuncurrency

/*
 Основным понятием является очередь (queue).
 Когда мы говорим о многопоточности в iOS с точки зрения разработчика iOS приложений, мы говорим об очередях (queues).
 Очереди (queues) — это обычные очереди, в которые выстраиваются замыкания (closure — анонимные блоки кода).
 Система выполняет их согласно очереди, “выдергивая” следующего по очереди и запуская его на выполнение в соответствующем этой очереди потоке.
 Очереди (queues) следуют FIFO паттерну (First In, First Out), это означает, что тот, кто первым был поставлен в очередь, будет первым направлен на выполнение.
 У вас может быть множество очередей (queues) и система “выдергивает” замыкания по одному из каждой очереди и запускает их на выполнение в их собственных потоках.
 Таким образом, вы получаете многопоточность.
 
 Очереди (queues) могут быть “serial” (последовательными), когда задача (замыкание), которая находится на вершине очереди, “вытягивается” iOS и работает до тех пор, пока не закончится, затем вытягивается следующий элемент из очереди.
 Очереди (queues) могут быть “concurrent” (многопоточными), когда система “вытягивает” замыкание, находящееся на вершине очереди, и запускает ее на выполнение в определенном потоке.
 
 Как только очередь (queue) создана, задание на ней можно разместить с помощью двух функций: sync — синхронное выполнение по отношению к текущей очереди и async — асинхронное выполнение по отношению к текущей очереди.
 Синхронная функция sync возвращает управление на текущую очередь только после полного завершения задания, тем самым блокируя текущую очередь.
 Асинхронная функция async, в противоположность функции sync, возвращает управление на текущую очередь немедленно после запуска задания на выполнение в другой очереди, не ожидая его завершения. Таким образом, асинхронная функция async не блокирует выполнение заданий на текущей очереди.
 
 Задача разработчика состоит только в выборе очереди и добавлении задания (как правило, замыкания) в эту очередь синхронно с помощью функции sync или асинхронно с помощью функции async, дальше работает исключительно iOS.
 
 Помимо пользовательских очередей, которые нужно специально создавать, система iOS предоставляет в распоряжение разработчика готовые (out-of-the-box) глобальные очереди (queues). Их 5:

 1) serial очередь Main queue, в которой происходят все операции с пользовательским интерфейсом (UI).
 2) 4 фоновых concurrent (параллельных) глобальных очереди с разным качеством обслуживания qos и разными приоритетами.
 */

// MARK: Cuncurrency problem

/*
 Основных проблемы три:

 1) cостояние гонки (race condition) — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода
 
 2) инверсия приоритетов (priority inversion)
 
 3) взаимная блокировка (deadlock) — ситуация в многопоточной системе, при которой несколько потоков находятся в состоянии бесконечного ожидания ресурсов, занятых самими этими потоками
 */

// MARK: Thread - поток, низкоуровневый механизм, мало используется

let one = Thread() {
    // вычисления
}

one.start() // нужно запустить для выполнения

// Синхронизация потоков - NSLock

var count = 0

let threadOne = Thread {
    for _ in 1...1000 {
        count += 1
    }
}

let threadTwo = Thread {
    for _ in 1...1000 {
        count += 1
    }
}

threadOne.start()
threadTwo.start()

// count может быть меньше 2000 из-за отсутствия синхронизации
// добавим NSLock для синхронизации

let lock = NSLock()
var counter = 0

let threadThree = Thread {
    for _ in 1...1000 {
        lock.lock()
        counter += 1
        lock.unlock()
    }
}

let threadFour = Thread {
    for _ in 1...1000 {
        lock.lock()
        counter += 1
        lock.unlock()
    }
}

threadThree.start()
threadFour.start()

let x = counter

// counter всегда будет 2000

// MARK: GCD

let queue = DispatchQueue.global()
queue.async {
    // вычисления в фоне
}

// синхронный и асинхронный код

queue.sync {
    print("1")
}
print("2")

// 1 2 - порядок гарантирован

queue.async {
    print("1")
}
print("2")

// нет синхронизации - порядок не гарантирован

var label = UILabel()

// Главная очередь - весь UI, анимации и реакции на ввод пользователей(последовательная очередь)

DispatchQueue.main.async {
    label.text = "Hello"
}

// Какие бывают очереди по приоритету(параллельные очереди)

DispatchQueue.global(qos: .userInteractive)
DispatchQueue.global(qos: .userInitiated)
DispatchQueue.global() // или qos: .default
DispatchQueue.global(qos: .utility)
DispatchQueue.global(qos: .background)

// Можно создать свою очередь

let demoSerialQueue = DispatchQueue(label: "Serial", qos: .utility)
let demoConcurrentQueue = DispatchQueue(label: "Concurrent", qos: .utility, attributes: .concurrent)

// DispatchSemaphore - позволяет ограничить число одновременно выполняемых задач

let semaphore = DispatchSemaphore(value: 2)

// ограничение в две очереди

for _ in 1...4 {
    DispatchQueue.global().async {
        semaphore.wait()
        sleep(1)
        semaphore.signal()
    }
}

// На главной потоке вызываем только асинхронный код

DispatchQueue.main.async {
    // иначе получим deadlock
}

// Но если нужно сделать синхронно на главном потоке, то используем функцию проверки:

func syncOnMainThread<T>(exexutive block: () throws -> T) rethrows -> T {
    if Thread.isMainThread {
        return try block()
    }
    
    return try DispatchQueue.main.sync(execute: block)
}

// отложенное действие

let queueMain = DispatchQueue.main

queueMain.asyncAfter(deadline: .now() + 1.25) {
    print("Hello")
}

// MARK: Operation

// Операция - законченная задача, абстрактный класс
// Жизненный цикл: Создание -> Подготовка -> Использование -> Завершение

let queueOperation = OperationQueue()
queueOperation.maxConcurrentOperationCount = 1 // ограничение количество параллельных операций
queueOperation.qualityOfService = .utility // приоритет
queueOperation.isSuspended = true // остановка операций на данной очереди

// Добавление операций

queueOperation.addOperation {
    // задача
}

// Операции бывают синхронные и асинхронные
